package modele;

import java.io.IOException;
import java.util.*;
import java.util.Map.Entry;

import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;

import xml.DeserialiseurDemandeDeLivraisonXML;
import xml.DeserialiseurPlanXML;
import xml.ExceptionXML;

/**
 * 
 */
public class DemandeDeLivraison {

	/**
     * La tournee qui correspond a la demande de livraisons. Vide lors de la 
     * creation de l'objet DemandeDeLivraison, elle est calculee par la methode
     * calculTournee.
     * 
     * @see calculerTournee
     */
    protected Tournee tournee;

    /**
     * Les fenetres listees dans le fichier XML de demande de livraisons.
     */
    protected List<FenetreTemporelle> fenetres;

    /**
     * La livraison de depart et d'arrivee de la tournee.
     */
    protected Livraison entrepot;

    /**
     * Le nombre de livraisons totale du fichier XML de demande de livraisons +
     * la livraison representant l'entrepot
     */
    protected int nbLivraisons;
    
    /**
     * Default constructor
     */
    public DemandeDeLivraison() {
    }
    
    public void chargerLivraison(Plan plan){
    	try {
    		fenetres = new ArrayList<FenetreTemporelle>();
    		DeserialiseurDemandeDeLivraisonXML.charger(this,plan);
		} catch (ParserConfigurationException | SAXException | IOException
				| ExceptionXML e) {
			// TODO Auto-generated catch block
			System.out.println("Exception constructeur livraisons");			
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
    }

    /**
     * 
     * @param map
     * @param value
     * @return
     */
    public Integer getKeyByValue(Map<Integer, Livraison> map, Livraison value) {
    	
        Integer key=0;
        for (Entry<Integer, Livraison> entry : map.entrySet()) {
            if (Objects.equals(value, entry.getValue())) {
                key=entry.getKey();
            }
        }
        return key;
    }
    
    /**
     * @param livraison1 
     * @param livraison2
     */
    protected void modifierTournee(Livraison livraison1, Livraison livraison2) {
        // TODO implement here
    }

    /**
     * @param livraison
     */
    protected void supprimeLivraison(Livraison livraison) {
        // TODO implement here
    }

    /**
     * @param livraisonAvant 
     * @param livraison
     */
    protected void ajouteLivraison(Livraison livraisonAvant, Livraison livraison) {
        // TODO implement here
    }

    /**
     * @param plan
     */
    protected void calculerTournee(Plan plan, TSP1 tsp) {
        // TODO implement here
    	
    	// Calcul des plus courts chemins a partir d'un livraison sur tout le plan
    	calculDesPlusCourtsChemins(plan);

    	// Creation des correspondances entre un sommet (Integer) et une livraison
		Map<Integer,Livraison> mapLivraisons = correspondanceLivraisons();
		
    	// Generation des arcs du graphe de livraisons
    	int couts[][] = genererTableauArcs(mapLivraisons);
    	
    	// Generation du graphe de livraisons
    	GrapheLivraisons graphe = new GrapheLivraisons(nbLivraisons, couts);
    	
    	// Recherche de la solution avec TSP
    	tsp.chercheSolution(0, graphe);
    	
    	// Recuperer l'ordre des livraisons a effectuer grace a TSP
    	LinkedList<Livraison> livraisonsEnOrdre = new LinkedList<Livraison>();
    	livraisonsEnOrdre = recupererLivraisonsEnOrdre(graphe, tsp, mapLivraisons);
    	
    	// Récupérer l'ordre des itinéraires entre les livraisons.
    	List<Itineraire> itinerairesEnOrdre = new LinkedList<Itineraire>();
    	itinerairesEnOrdre = recupererItinerairesEnOrdre(livraisonsEnOrdre, mapLivraisons,couts);
    	
    	// Créer la tournée
    	int coutTotalSolution = tsp.getCoutSolution();
    	Tournee tournee = new Tournee(this, entrepot, coutTotalSolution, itinerairesEnOrdre);
    }


    /**
     * @param plan 
     * @param depart 
     * @param arrivee
     */
    protected void calculPlusCourtChemin(Plan plan, Livraison depart, Livraison arrivee) {
        // TODO implement here
    }

    /**
     * 
     */
    protected void genereFeuilleDeRoute() {
        // TODO implement here
    }
    
    /**
     * Permet d'ajouter une livraison. Ne doit servir que lors de la création de la demande de livraison lors de l'ajout de l'entrepot
     * @param Livraison entrepot
     */
	public void ajouteEntrepot(Livraison entrepot) {
		this.entrepot = entrepot;
	}
	
    /**
     * Permet d'ajouter une fenetre temporelle. Ne doit servir que lors de la création de la demande de livraison
     * @param FenetreTemporelle fenetreTemporelle
     */
	public void ajouteFenetreTemporelle(FenetreTemporelle fenetreTemporelle) {
		this.fenetres.add(fenetreTemporelle);
	}
	
	@Override
	public String toString() {
		String s = this.entrepot.toString() + "/n";
		for (FenetreTemporelle f : this.fenetres) {
			s += f.toString() +"/n";	 // TODO FenetreTemporelle.toString()
		}
		return s;
	}

	public Tournee getTournee() {
		return tournee;
	}

	public void setTournee(Tournee tournee) {
		this.tournee = tournee;
	}

	public List<FenetreTemporelle> getFenetres() {
		return fenetres;
	}

	public void setFenetres(List<FenetreTemporelle> fenetres) {
		this.fenetres = fenetres;
	}

	public Livraison getEntrepot() {
		return entrepot;
	}

	public void setEntrepot(Livraison entrepot) {
		this.entrepot = entrepot;
	}


}